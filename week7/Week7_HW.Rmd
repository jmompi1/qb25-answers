---
title: "Week7_HW"
author: "Joy Mompi"
date: "2025-11-05"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r cars}
#Step 1.1: Loading and filtering the data
#Begin by loading the data into R. You will want to make sure the data are in a matrix as opposed to a dataframe so you can use the as.matrix function to do this conversion.

setwd("~/qb25-answers/week7")
matrix_df <- read.table("~/qb25-answers/week7/read_matrix.tsv")
gtex_matrix <- as.matrix(matrix_df)


#For the PCA analysis you will only want to use the most variable genes. You can use the function rowSds to find the standard deviation of each gene. Select the top 500 most variant genes for running the PCA. You will want to keep the whole dataset for downstream analysis so make a new copy of the data when filtering.
library(dplyr)


gtex_sd <- rowSds(gtex_matrix)
gtex_sd <- sort(gtex_sd, decreasing = TRUE)

top_500 <- gtex_sd[1:500]
top500_matrix <- gtex_matrix[top_500,]
top500_matrix <- as.matrix(top500_matrix)

?rowSds






#Step 1.2: Run the PCA analysis
#To perform PCA, you will use the function prcomp. This function expects samples in rows so you will need to invert your matrix (you can use the transpose function t to do this).
transposed_top500 <- t(top500_matrix)
pca_transposed_top500 <- prcomp(transposed_top500)

#The returned PCA object has several types of information. The transformed data into PC coordinates are in a matrix x with samples corresponding to rows and principal components corresponding to columns (for example, to access the first and second PC coordinates for the first sample, you would use data$x[1,1:2] where data is the object returned by prcomp). The PCA object also contains the amount of variance explained by each principal component in the attribute sdev (i.e. data$sdev).

pca_transposed_top500$x[1,1:2]


#Step 1.3: Plot the first two PCs and plot the amount of variance explained for each PC
#Plot each sample using its first two PC coordinates. To do this, you will need to create a new tibble (dataframe) with columns corresponding to the first and second PCs as well as the sample names. Make sure to include a legend and if you can, use color to denote tissue and point shapes to denote replicate number. To do this, you can use the function tidyr::separate to split the sample names into two columns, tissue and replicate.

print(pca_transposed_top500$x[1,1:2])

top500_pca_data = tibble(samples = row.names(transposed_top500), PC1= pca_transposed_top500$x[,1], PC2 = pca_transposed_top500$x[,2])
library(dplyr)

top500_pca_data <- top500_pca_data%>%
  separate(samples, into = c("tissue", "replicate"), sep = "_")

ex1.3pcaplot <- ggplot(top500_pca_data, aes(PC1, PC2, color=tissue, shape=replicate)) +
  geom_point(size=3) +
  scale_color_discrete()

#Save this plot to turn in.
ggsave("ex1.3pcaplot.png", plot = ex1.3pcaplot, path = "~/qb25-answers/week7")

#Examine the PCA plot. Does everything look okay (We wouldn’t ask if it did)?


#What does the PCA plot suggest to you about the data? Why?


#Fix any problems that the PCA reveals.

#What feature explains the first principal component (simply saying “tissue” is not sufficient)?

#Also plot the amount of variance explained by each PC as a bar chart. As always, remember to label your axes.

#Save this plot to turn in.




```

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}

```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
